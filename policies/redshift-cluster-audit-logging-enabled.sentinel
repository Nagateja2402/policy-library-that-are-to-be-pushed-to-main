# This policy checks if resources of type 'aws_redshift_cluster' have the 
# enable attribute set to true in logging or referenced to the
# resource 'aws_redshift_logging'

import "tfplan/v2" as tfplan
import "tfconfig/v2" as tfconfig
import "tfresources" as tf
import "report" as report
import "collection" as collection
import "collection/maps" as maps
import "strings"

# Constants
const = {
	"policy_name":                           "redshift-cluster-public-access-check",
	"message":                               "Parameter 'require_ssl' should be true for AWS Redshift Parameter Group. Refer to https://docs.aws.amazon.com/securityhub/latest/userguide/redshift-controls.html#redshift-2 for more details.",
	"resource_aws_redshift_cluster":         "aws_redshift_cluster",
	"resource_aws_redshift_cluster_logging": "aws_redshift_logging",
	"address":        "address",
	"module_prefix":  "module.",
	"module_address": "module_address",
}

# Functions

get_violations = func(redshift_cluster_resources, redshift_cluster_logging_resources, config_resources) {
	return collection.reject(redshift_cluster_resources, func(res) {
		redshift_cluster_logging_config_resources = collection.find(config_resources, func(config_resource) {
			return maps.get(config_resource, "type") is const.resource_aws_redshift_cluster_logging
		})
		logging_resource = maps.get(res, "values.logging" , [])

		redshift_logging_enable_resources = collection.find(logging_resource, func(res) {
			return res is not empty
		})
		redshift_logging_referenced_to_redshift_cluster_resources = redshift_cluster_logging_config_resources.config.cluster_identifier.references[-1]
		redshift_cluster_address = res.address
		if(redshift_logging_referenced_to_redshift_cluster_resources is redshift_cluster_address) {
			return true
		}
		print(redshift_logging_referenced_to_redshift_cluster_resources)
		if(redshift_logging_enable_resources.enable is false) {
			return false
		}

		return true
		
		# # Extract the address of resource aws_redshift_parameter_group which is refereced to the resource aws_redshift_cluster
		# redshift_cluster_referenced_parameter_group_address = maps.get(redshift_cluster_config_resources, "config.cluster_parameter_group_name.references", "")
		# if redshift_cluster_referenced_parameter_group_address is empty {
		# 	return false
		# }

		# # Get the resources of the parameter group which is referenced to the aws_redshift_cluster
		# redshift_cluster_referenced_parameter_group_resources = collection.find(redshift_parameter_group_resources, func(parameter_group_resource) {
		# 	parameter_group_address_without_module = resource_address_without_module_address(parameter_group_resource)
		# 	return parameter_group_address_without_module is redshift_cluster_referenced_parameter_group_address[-1]
		# })

		# # Check if the parameters in the aws_redshift-parameter_group contains the require_ssl attribute and is set to 'true' else will lead to a violation
		# redshift_cluster_parameters = maps.get(redshift_cluster_referenced_parameter_group_resources, "values.parameter", [])
		# return collection.find(redshift_cluster_parameters, func(redshift_cluster_parameter) {
		# 	return maps.get(redshift_cluster_parameter, "name", "") is "require_ssl" and maps.get(redshift_cluster_parameter, "value", "") is "true"
		# }) is defined
	})
}

# Removes module address prefix from a resource
# and returns back the localized address for a module.
resource_address_without_module_address = func(res) {
	resource_addr = res[const.address]
	# Check for root module
	if not strings.has_prefix(resource_addr, const.module_prefix) {
		return resource_addr
	}

	module_addr_prefix = res[const.module_address] + "."
	return strings.trim_prefix(resource_addr, module_addr_prefix)
}

# Variables

redshift_clusters = tf.plan(tfplan.planned_values.resources).type(const.resource_aws_redshift_cluster).resources
redshift_cluster_logging_resource = tf.plan(tfplan.planned_values.resources).type(const.resource_aws_redshift_cluster_logging).resources
config_resources = tf.config(tfconfig.resources).resources
violations = get_violations(redshift_clusters, redshift_cluster_logging_resource, config_resources)

summary = {
	"policy_name": const.policy_name,
	"violations": map violations as _, v {
		{
			"address":        v.address,
			"module_address": v.module_address,
			"message":        const.message,
		}
	},
}

# Outputs
print(report.generate_policy_report(summary))

# Rules

main = rule {
	violations is empty
}
